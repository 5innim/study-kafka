# Kafka 탄생
LinkedIn은 서비스가 확장됨에 따라 소스 애플리케이션과 타겟 애플리케이션의 수가 급증하면서, 데이터 전송 라인이 기하급수적으로 복잡해졌음.
이러한 문제를 해결하기 위해, 내부 데이터 흐름을 중앙에서 관리하고 처리할 수 있는 특화된 솔루션이 필요하게 되었고, 그 결과로 탄생한 것이 Kafka.

LinkedIn에서는 Kafka를 개발하기 이전에 다양한 기존의 메시징 시스템을 적용하였지만, LinkedIn의 요구사항을 충족하기는 어려웠으며 이에 대응되는 Kafka의
특징으로 아래 내용을 책에서 소개한다. 

<br/>
<br/>

## Kafka의 중앙배치에 의한 서버간의 decoupling
기존 source application에서 target application으로 데이터를 직접적으로 전송하는 방식은 두 서버간의 결합도를 높이면서, 서비스 확장에 따라 데이터 전송 라인이 급증하는 단점이 부각되었다.
<br/>
Kafka가 중앙에 배치됨으로써 기존의 source와 target은 단순히 producer와 consumer로 역할을 한다. 이러한 구조는 두 서버간의 결합도를 완화시킨다. 
<img width="1155" alt="스크린샷 2024-11-12 오후 10 17 10" src="https://github.com/user-attachments/assets/685addff-2b6e-41ea-856a-3f5591a5fea8">

<br/>
<br/>

## Kafka message data format
Kafka를 통해 전달할 수 있는 data format은 사실 상 제한이 없다. 직렬화, 역직렬화를 통해 ByteArray로 통신하기 때문이다.

<br/>
<br/>

## 높은 처리량
Kafka에서는 메시지 전송 시 batch 단위로 전송함으로써 RTT를 줄일 수 있다. 또한 동일 목적의 데이터를 여러 파티션에 분배하고 컨슈머 개수를 늘려 병렬처리함으로써 동일 시간당 데이터 처리량을 늘릴 수 있다.
<img width="777" alt="스크린샷 2024-11-12 오후 10 36 29" src="https://github.com/user-attachments/assets/b38ac6ac-dc92-4507-a26f-cf815f526cb0">

<br/>
<br/>

## 확장성
Kafka는 브로커 개수를 scale-out, scale-in 하여 클러스터 구성이 가능하므로 트래픽 상황에 따라 유연하게 대처가 가능하다. 각자기 트래픽이 몰리는 상황에서 안정적으로 확장이 가능하며 클러스터의 무중단 운영을 지원한다.   

<br/>
<br/>

## 영속성
Kafka는 다른 메시징 플랫폼과 다르게 전송받은 데이터를 메모리에 저장하지 않고 파일 시스템에 저장한다. 
파일 시스템에 데이터를 적재하고 사용하는 것은 보편적으로 느릴 수 있지만, Kafka는 운영체제 레벨에서 파일 시스템을 최대한 활용하는 방법을 적용하였다. 
운영체제에서는 파일 I/O 성능 향상을 위해 페이지 캐시 영역을 메모리에 따로 생성해서 사용한다. 
메모리 영역을 사용하여 한번 읽은 파일 내용은 메모리에 캐싱하여 사용하기 때문에 카프카가 파일 시스템에 저장하고 데이터를 저장, 전송하더라도 처리량이 높은 것이다. 
디스크 기반의 파일 시스템을 활용한 덕분에 브로커에서 장애 발생으로 급작스럽게 종료되더라도 프로세스를 재시작하여 안전하게 데이터를 다시 처리할 수 있다.

<br/>
<br/>

## 고가용성
3개 이상의 서버들로 운영되는 카프카 클러스터는 일부 서버에 장애가 발생하더라도 무중단으로 안전하고 지속적으로 데이터를 처리할 수 있다. 
클러스터로 이루어진 카프카는 데이터의 복제를 통해 고가용성의 특징을 가진다. 
프로듀서로 전송받은 데이터를 여러 브로커 중 1대의 브로커에만 저장하는 것이 아니라 또 다른 브로커에도 저장하는 것이다. 한 브로커에 장애가 발생하더라도 복제된 데이터를 가진 다른 브로커가 역할을 대체할 수 있다.
(클러스터 구성 시 브로커 개수에는 제한이 없다.)

* 카프카 클러스터를 3대 이상의 브로커들로 구성해야 하는 이유
min.insync.replicas 옵션: 파티션 리더와 동기화 상태를 유지하는 복제본의 최소 개수를 설정하는 옵션. (데이터 일관성을 보장하고 데이터 유실을 방지하기 위해 사용.)
=> 해당 옵션을 2로 설정하면 최소 2개 이상의 브로커에 데이터가 완전히 복제됨을 보장한다.
   min.insync.replicas 옵션값보다 작은 수의 브로커가 클러스터에 존재하는 겨우에는 쓰기작업을 할 수 없다.
   따라서 하나의 브로커에 장애가 나는 경우에도 지속적으로 데이터를 처리하기 위해 3대 이상의 브로커를 사용해야한다.


  








