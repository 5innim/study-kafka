# 토픽과 파티션

토픽은 카프카에서 데이터를 구분하기 위해 사용하는 단위

토픽은 1개 이상의 파티션을 소유

파티션에는 프로듀서가 보낸 데이터들이 들어가 저장되는데 이 데이터를 ‘레코드(record)’라고 부른다. 

파티션은 카프카의 병렬처리의 핵심, 그룹으로 묶인 컨슈머들이 레코드를 병렬로 처리할 수 있도록 매칭된다. 즉, 컨슈머의 scale out 에 의한 개수 증가와 파티션 개수 증가로 병렬 처리로 인한 처리량 증가.

파티션은 큐와 비슷한 구조. 다만 카프카에서는 데이터를 가져간다고 하더라도 삭제하지 않는다. 파티션의 레코드는 컨슈머가 가져가는 것과 별개로 관리된다. ⇒ 이러한 특징 때문에 토픽의 레코드는 다양한 목적을 가진 여러 컨슈머 그룹들이 토픽의 데이터를 여러 번 가져갈 수 있다. 

### 토픽 이름 제약조건:

- 빈 문자열 토픽 이름은 지원하지 않음
- 토픽 이름은 마침표 하나(.) 또는 마침표 둘(..)로 생성될 수 없음
- 토픽 이름의 길이는 249자 미만으로 생성되어야 함
- 토픽 이름은 영어 대소문자와 숫자 0부터 9 그리고 마침표(.), 언더바(_), 하이픈(-) 조합으로 생성할 수 있음(이외의 문자열이 포함된 토픽 이름은 생성 불가)
- 카프카 내부 로직 관리 목적으로 사용되는 2개 토픽(__consumer_offsets, __transaction_state)과 동일한 이름으로 생성 불가능
- 카프카 내부적으로 사용하는 로직 때문에 토픽 이름에 마침표(.)와 언더바(_)가 동시에 들어가면 안됨(생성은 가능하나 사용 시 이슈가 발생할 수 있기 때문에 WARNING 메세지가 발생함)
- 이미 생성된 토픽 이름의 마침표(.)를 언더바(_)로 바꾸는 경우나 이 반대의 경우 신규 토픽 이름과 동일하다면 생성할 수 없음(to.pic 이름의 토픽이 생성되어 있다면 to_pic 이름의 토픽을 생성할 수 없음)

토픽 이름을 모호하게 작성하면 유지보수 시 큰 어려움을 겪을 수 있음

(최소한 토픽 이름을 통해 어떤 개발환경에서 사용되는 것인지 판단 가능해야하고 어떤 어플리케이션에서 어떤 데이터 타입으로 사용되는지 유추할 수 있어야 함!)

전사에서 공용으로 사용하고 있는 카프카라면 토픽의 ownership을 가진 팀의 이름을 추가하는 것도 고려해볼만 하고

토픽 이름에 대한 규칙을 사전에 정의하고 구성원들이 그 규칙을 잘 따르는 것이 가장 중요함

=> 아무리 규칙을 정해도 따르지 않으면 예측하지 못한 방향으로 토픽이름이 생성될 것임

(카프카는 토픽 이름 변경을 지원하지 않으므로 이름 변경을 위해선 삭제 후 다시 생성해야 함)

### 레코드

레코드는 timestamp, key, value, offset, header 로 구성되어있다. 

- 프로듀서가 생성한 레코드가 브로커로 전송되면 offset 과 timestamp가 지정되어 저장된다.
- 브로커에 한번 적재된 레코드는 수정할 수 없고 로그 리텐션 기간 또는 용량에 따라서만 삭제된다.

timestamp: 프로듀서에서 해당 레코드가 생성된 시점의 유닉스 타임이 설정된다. (프로듀서가 레코드를 생성할 때 임의의 타임스탬프 값 설정이 가능하다. 또한 토픽 설정에 따라 브로커에 적재된 시간(LogAppendTime)으로 설정될 수도 있다.)

key: 메시지 키는 메시지 값을 순서대로 처리하거나 메시지 값의 종류를 나타내기 위해 사용한다. 

- 메시지 키를 사용하면 프로듀서가 토픽에 레코드를 전송할 때 메시지 키의 해시값을 토대로 파티션을 지정하게 된다. (즉, 동일한 메시지 키라면 동일 파티션에 적재된다. 파티션 개수가 변경되면 메시지 키와 파티션 매칭이 달라지게 되므로 주의해야한다.)
- 메시지 키를 사용하지 않는다면 프로듀서에서 레코드를 전송할 때 메시지 키를 선언하지 않으면 된다. 메시지 키를 선언하지 않으면 null로 설정된다.(null로 설정된 레코드는 프로듀서 기본 설정 파티셔너에 따라서 파티션에 분배되어 적재된다.)

value: 메시지 값에는 실질적으로 처리할 데이터가 들어 있다.

- 메시지 키와 메시지 값은 직렬화되어 브로커로 전송되기 때문에 컨슈머가 이용할 때는 직렬화한 형태와 동일한 형태로 역직렬화를 수행해야 한다.

offset: 레코드의 offset은 0 이상의 숫자로 이루어져 있다. 레코드의 offset은 직접 지정 불가하며 브로커에 저장될 때 이전에 전송된 레코드의 오프셋 +1 값으로 생성된다.

- offset은 카프카 컨슈머가 데이터를 가져갈 때 사용된다. offset을 사용하면 컨슈머 그룹으로 이루어진 카프카 컨슈머들이 파티션의 데이터를 어디까지 가져갔는지 명확히 지정할 수 있다.

header: 헤더는 레코드의 추가적인 정보를 담는 메타데이터 저장소 용도로 사용한다. 

- 헤더는 키/값 형태로 데이터를 추가하여 레코드의 속성(스키마 버전 등)을 저장하여 컨슈머에서 참조할 수 있다.